import nbformat as nbf

nb = nbf.v4.new_notebook()

nb.cells = [
    nbf.v4.new_markdown_cell(
        "# Bitcoin News Sentiment Analysis (LiteLLM, Modular, Table Display)\n"
        "\n"
        "This notebook fetches the latest Bitcoin news, analyzes sentiment using an LLM (via LiteLLM), and displays the results in a table.\n"
        "\n"
        "**Instructions:**\n"
        "- Make sure you have a `.env` file with your API keys (NEWS_API_KEY, OPENAI_API_KEY, etc).\n"
        "- Run the setup cell below to install dependencies.\n"
        "- You can change the LLM provider in the configuration cell."
    ),
    nbf.v4.new_code_cell(
        "!pip install -q litellm requests python-dotenv pandas tiktoken ipywidgets plotly"
    ),
    nbf.v4.new_markdown_cell("## Imports and Configuration"),
    nbf.v4.new_code_cell(
        "import os\n"
        "import json\n"
        "import hashlib\n"
        "from datetime import datetime, timezone\n"
        "from pathlib import Path\n"
        "from typing import List, Dict, Optional, Tuple\n"
        "from dataclasses import dataclass\n"
        "\n"
        "import requests\n"
        "import pandas as pd\n"
        "from dotenv import load_dotenv\n"
        "import tiktoken\n"
        "from litellm import completion\n"
        "\n"
        "# For table display\n"
        "from IPython.display import display, HTML\n"
        "import ipywidgets as widgets\n"
        "\n"
        "# For optional visualization\n"
        "import plotly.express as px"
    ),
    nbf.v4.new_markdown_cell("### Create Config class with classmethod"),
    nbf.v4.new_code_cell(
        "@dataclass\n"
        "class Config:\n"
        "    \"\"\"Configuration settings for the application.\"\"\"\n"
        "    NEWS_API_KEY: str\n"
        "    OPENAI_API_KEY: Optional[str]\n"
        "    TOGETHER_API_KEY: Optional[str]\n"
        "    GOOGLE_API_KEY: Optional[str]\n"
        "    HUGGINGFACE_API_KEY: Optional[str]\n"
        "    PROVIDER: str = \"together_ai\"\n"
        "    MODEL_ID: str = \"mistralai/Mixtral-8x7B-Instruct-v0.1\"\n"
        "    MAX_TOKENS: int = 1000\n"
        "    DATA_DIR: Path = Path.cwd() / \"data\"\n"
        "    CSV_PATH: Path = DATA_DIR / \"bitcoin_news_sentiment.csv\"\n"
        "    CACHE_PATH: Path = DATA_DIR / \"article_cache.json\"\n"
        "    PROMPT_TEMPLATE: str = (\n"
        "        \"You are a financial sentiment analyst.\\n\"\n"
        "        \"Classify the sentiment of the following Bitcoin news article as one of \"\n"
        "        \"'Positive', 'Neutral', or 'Negative'. Respond with ONLY the full word (not abbreviated).\\n\\n\"\n"
        "        \"Article: {text}\\n\\nSentiment:\"\n"
        "    )\n"
        "\n"
        "    @classmethod\n"
        "    def load(cls) -> 'Config':\n"
        "        \"\"\"Load configuration from environment variables.\"\"\"\n"
        "        load_dotenv()\n"
        "        \n"
        "        if not os.getenv(\"NEWS_API_KEY\"):\n"
        "            raise RuntimeError(\"NEWS_API_KEY is not set â€“ please export it or add to .env\")\n"
        "            \n"
        "        return cls(\n"
        "            NEWS_API_KEY=os.getenv(\"NEWS_API_KEY\", \"\"),\n"
        "            OPENAI_API_KEY=os.getenv(\"OPENAI_API_KEY\"),\n"
        "            TOGETHER_API_KEY=os.getenv(\"TOGETHER_API_KEY\"),\n"
        "            GOOGLE_API_KEY=os.getenv(\"GOOGLE_API_KEY\"),\n"
        "            HUGGINGFACE_API_KEY=os.getenv(\"HUGGINGFACE_API_KEY\"),\n"
        "        )\n"
        "\n"
        "    @property\n"
        "    def provider_configs(self) -> Dict[str, Dict]:\n"
        "        \"\"\"Get provider-specific configurations.\"\"\"\n"
        "        return {\n"
        "            \"together_ai\": {\n"
        "                \"model\": \"together_ai/mistralai/Mixtral-8x7B-Instruct-v0.1\",\n"
        "                \"api_key\": self.TOGETHER_API_KEY,\n"
        "            },\n"
        "            \"openai\": {\n"
        "                \"model\": \"gpt-3.5-turbo\",\n"
        "                \"api_key\": self.OPENAI_API_KEY,\n"
        "            },\n"
        "            \"huggingface\": {\n"
        "                \"model\": \"huggingface/HuggingFaceH4/zephyr-7b-beta\",\n"
        "                \"api_key\": self.HUGGINGFACE_API_KEY,\n"
        "            },\n"
        "            \"gemini\": {\n"
        "                \"model\": \"gemini-pro\",\n"
        "                \"api_key\": self.GOOGLE_API_KEY,\n"
        "            }\n"
        "        }\n"
        "\n"
        "# Load configuration\n"
        "config = Config.load()"
    ),
    nbf.v4.new_markdown_cell("## Helper Functions"),
    nbf.v4.new_code_cell(
        "def fetch_bitcoin_news(config: Config, page_size: int = 10) -> List[Dict]:\n"
        "    url = 'https://newsapi.org/v2/everything'\n"
        "    params = {\n"
        "        'q': 'Bitcoin',\n"
        "        'language': 'en',\n"
        "        'sortBy': 'publishedAt',\n"
        "        'pageSize': page_size,\n"
        "        'apiKey': config.NEWS_API_KEY,\n"
        "    }\n"
        "    r = requests.get(url, params=params, timeout=15)\n"
        "    r.raise_for_status()\n"
        "    return r.json().get('articles', [])\n"
        "\n"
        "def count_tokens(text: str) -> int:\n"
        "    encoding = tiktoken.get_encoding('cl100k_base')\n"
        "    return len(encoding.encode(text))\n"
        "\n"
        "def truncate_text(text: str, max_tokens: int = 1000) -> str:\n"
        "    if count_tokens(text) <= max_tokens:\n"
        "        return text\n"
        "    sentences = text.split('. ')\n"
        "    truncated = []\n"
        "    current_tokens = 0\n"
        "    for sentence in sentences:\n"
        "        sentence_tokens = count_tokens(sentence)\n"
        "        if current_tokens + sentence_tokens <= max_tokens:\n"
        "            truncated.append(sentence)\n"
        "            current_tokens += sentence_tokens\n"
        "        else:\n"
        "            break\n"
        "    return '. '.join(truncated) + '.'\n"
        "\n"
        "def classify_sentiment(text: str, config: Config) -> Tuple[str, float]:\n"
        "    truncated_text = truncate_text(text, config.MAX_TOKENS)\n"
        "    prompt = config.PROMPT_TEMPLATE.format(text=truncated_text.strip())\n"
        "    provider_config = config.provider_configs[config.PROVIDER]\n"
        "    try:\n"
        "        response = completion(\n"
        "            model=provider_config['model'],\n"
        "            messages=[{'role': 'user', 'content': prompt}],\n"
        "            temperature=0,\n"
        "            max_tokens=1,\n"
        "            api_key=provider_config.get('api_key'),\n"
        "        )\n"
        "        result = response.choices[0].message.content.strip().split()[0]\n"
        "        return result, 0.0  # Cost is handled by LiteLLM\n"
        "    except Exception as e:\n"
        "        print(f\"Error with {config.PROVIDER} provider: {str(e)}\")\n"
        "        return \"Neutral\", 0.0"
    ),
    nbf.v4.new_markdown_cell("## Run Sentiment Analysis on Latest News"),
    nbf.v4.new_code_cell(
        "articles = fetch_bitcoin_news(config, page_size=10)\n"
        "rows = []\n"
        "total_cost = 0.0\n"
        "\n"
        "for art in articles:\n"
        "    headline = art.get('title', '').strip()\n"
        "    content = art.get('description', '') or art.get('content', '')\n"
        "    if not content:\n"
        "        continue\n"
        "    \n"
        "    sentiment, cost = classify_sentiment(content, config)\n"
        "    total_cost += cost\n"
        "    \n"
        "    rows.append({\n"
        "        'publishedAt': art.get('publishedAt'),\n"
        "        'headline': headline,\n"
        "        'sentiment': sentiment,\n"
        "        'score': 1 if sentiment.lower() == 'positive' else (-1 if sentiment.lower() == 'negative' else 0),\n"
        "        'url': art.get('url'),\n"
        "        'cost': cost,\n"
        "    })\n"
        "    print(f\"[{sentiment}] {headline[:80]}...\")\n"
        "\n"
        "df = pd.DataFrame(rows)\n"
        "df['publishedAt'] = pd.to_datetime(df['publishedAt'])\n"
        "df = df.sort_values('publishedAt', ascending=False)\n"
        "df.reset_index(drop=True, inplace=True)\n"
        "print(f\"Total cost: ${total_cost:.6f}\")\n"
        "df.head()"
    ),
    nbf.v4.new_markdown_cell("## Display Results as Interactive Table"),
    nbf.v4.new_code_cell(
        "def make_clickable(val):\n"
        "    return f'<a href=\"{val}\" target=\"_blank\">Link</a>' if pd.notnull(val) else ''\n"
        "\n"
        "display(HTML(df.to_html(escape=False, formatters={'url': make_clickable}, index=False)))"
    ),
    nbf.v4.new_markdown_cell("## Optional: Visualize Sentiment Distribution"),
    nbf.v4.new_code_cell(
        "fig = px.pie(\n"
        "    values=df['sentiment'].value_counts().values,\n"
        "    names=df['sentiment'].value_counts().index,\n"
        "    title='Sentiment Distribution',\n"
        "    color=df['sentiment'].value_counts().index,\n"
        "    color_discrete_map={'Positive': 'green', 'Neutral': 'gray', 'Negative': 'red'}\n"
        ")\n"
        "fig.show()"
    ),
]

with open("bitcoin_news_sentiment.ipynb", "w") as f:
    nbf.write(nb, f)

print("Notebook created: bitcoin_news_sentiment.ipynb") 